#+TITLE: Design Notes

Dumping ground for high level design notes

* Influences

Emacs - Extensible, uniform software environment.

Erlang - Message based, distributed software runtime w/ userspace
concurrency. "Let It Crash" philosophy.

Hypermedia - Self-describing, uniform interface. Thin general-purpose clients.

Unix - Composability of programs via stdio, pipes, and plaintext. Polyglot.

Plan 9 - Per-process hierarchical namespaces and hypermedia approach to plaintext via plumber

* Client and Runtime
** Goals

Communication between client and runtime is a simple message-based and transport
agnostic interface.

Runtime code should be able to run in several configurations:

- Cross-process, for client and runtime processes on the same machine.
- Over-network, for thin-clients that interact with runtime on different
  machines.
- In-process, for platforms that must run client-runtime in single
  process. (E.g. Mobile)

Client API should be simple and lean so bringing up new clients is low cost.

** Runtime

A typical lifecycle of the client and runtime may look like:

1. Clients opens a bidirectional channel to runtime.
2. Client and runtime trade message over bidirectional channel via client API.
3. When the client exists, it closes the channel, and runtime frees resources
   tied to connection.

The per-client state is maintained in the runtime, so client implemenation is
lean.

The client API will offer request-response style APIs on top of message passing
for convenience, but the channel is a bidirectional.

How the runtime is started may be platform dependent:

- On desktop, runtime daemon runs via typical service management (`systemd`, `launchd`, etc).
- On cloud, runtime may be always running as a service.
- On mobile, a in-process runtime may be spun up during application initialization.

** Runtime - High Level Lifecycle

1. Runtime is initialized in host process
2. Host process begins listening on some transport for new connections
3. Host process hands-off accepted connections to runtime
4. Runtime spawns a dedicated client process per connection
5. Interactions from client connection are processed and forwarded from client
   process to other processes in the runtime.
6. Responses, if any, are forwarded back on client connection.
7. When client task ends or connection is disconnected, the client process is terminated.

** Client API

The client API should be lightweight.

It should support:

- Request / Response
- Pub / Sub - including pushes from runtime
- Hypermedia-Driven Interface

** Client Library

The client API is largely implemented by client library.

Like `libdbus`, the underlying transport should be opaque to client programs -
it may use lower-level IPC mechanisms like unix domain sockets, or TCP, without
affecting API surface between client and client library.

** Hypermedia Client

The client implementation over client API is hypermedia-driven:

TODO: Add notes on hypermedia client

** vrsctl - CLI client

The `vrsctl` CLI is lightweight client to runtime that offers 1-1 mapping to
client API.

Per invocation, it will:
1. Open connection with runtime
2. Send specified message(s)
3. Wait for response(s)
4. Close connection to runtime when stdin closes and all requests were processed.

CLI can be used to bootstrap new clients that is able to launch `vrsctl`
directly, or as a development tool.

* Lyric Lang
** Goals

An embedded lisp dialect provides a single, uniform interface for everything -
code, data, interfaces, and protocol.

Interactions from the REPL or hypermedia interface should be exactly how the
applications are programmed, similar to how the language of the shell can be
used to write scripts.

All data, including interface markup, can be captured by the dialect's
s-expressions.

** Why write your own Lisp?

Paul Graham put it best:

#+begin_quote
A language is by definition reusable. The more of your application you can push
down into a language for writing that type of application, the more of your
software will be reusable.
â€” Paul Graham
#+end_quote

When the language is tailored to the environment, software can be simple and
rich, similar to how shell languages are designed around IO redirection.

It is also my impression that a bulk of software written today fall into
standard, institutionalized patterns - with engineers acting as "human
compilers" to write this code out by hand. Why not let the computer write that
code via higher-level intermediate language?

See also - [Greeenspun's Tenth Rule](https://en.wikipedia.org/wiki/Greenspun's_tenth_rule)

** Lisp as the Uniform Interface

In vrs, it's Lisp all the way down:

- Scripting language is Lisp
- Modules extends runtime via bindings in Lisp
- User interfaces are s-expressions
- Hypermedia controls within interface are s-expressions
- Messages between client and runtime are s-expressions

Lisp is the substrate for code and data that ties the client, runtime, and
modules together.

Lisp is a practical choice for highly interactive, moldable,
application-specific progamming environments.

[Twitter rant](https://twitter.com/leoshimo/status/1694375158897574227)

*** Lisp as Hypermedia

v0.1 sketch of Lisp as Hypermedia

#+begin_src lisp
'((:text_field :id search
               :on_change on_search_text_change
               :value "query input")
  (:ul :id search_results
       (:li :content "Element 1"
            :on_click '(action_for_elem_1))
       (:li :content "Element 2"
            :on_click '(action_for_elem_2))
       (:li :content "Element 3"
            :on_click '(action_for_elem_3))))
#+end_src

* Runtime Program Execution

The runtime spawns and manages processes. These are not OS processes, but
lightweight threads of execution like [Erlang Processes](https://www.erlang.org/docs/22/reference_manual/processes.html).

Each process has its own Lisp environment for evaluating S-expressions.

Unlike Node, which uses callbacks to implement continuations, `lyric` is built
to support preemptive and cooperative multitasking during evaluation, similar to
BEAM VM.

Instead of a subscription + callback mechanism, the process's code describes
when IO is polled, when mailbox is queried, etc.

`lyric` and the runtime provides conveniences for typical patterns,
e.g. implementing long-running services, supervisors, request-response, etc.

* Process, Bytecode, and Fibers

The programs written in `lyric` support yielding - pausing and continuing
execution of bytecode sequences.

This makes it possible for runtime to drive evaluation of program via
asynchronous IO. Interpreter host captures signals yielded during program
execution, dispatches appropriate async IO, and continues execution once the IO
resource is ready.

The key motivation for this is to not tie an OS thread per paused program. A
`lyric` program waiting for IO does not block a thread, since it's runtime state
can be captured as a data structure.

E.g. A 10,000 sleeping processes "at rest" does not use 10,000 threads.

This makes it viable to model most things as programs - e.g. cron jobs are
programs that sleep in a loop:

#+begin_src lyric
(loop (sleep 10000)
      (do_a_thing))
#+end_src

** What is a Fiber

A fiber is a sequence of instructions that can be cooperatively scheduled. When
it runs an instruction to yield for, control flow is returned to caller that
initiated execution of fiber.

A fiber can later be resumed when the event that fiber was paused for occurs,
such as IO, message-passing, etc.

