#+TITLE: Design of vrs

Dumping ground for high level design notes

* Influences

Emacs - Extensible, uniform software environment 

Hypermedia - Self-describing, uniform interface of early browser applications 

Unix - Composability of programs via stdio, pipes, and plaintext. Polyglot.

Plan 9 - Per-process hierarchical namespaces and hypermedia approach to plaintext via plumber

Erlang - Message based, distributed software runtime w/ userspace concurrency.

* Client and Runtime
** Goals

Communication between client and runtime is a simple message-based and transport
agnostic interface.

Runtime code should be able to run in several configurations:

- Cross-process, for client and runtime processes on the same machine.
- Over-network, for thin-clients that interact with runtime on different
  machines.
- In-process, for platforms that want same-device client-runtime but cannot
  spawn separate process.

Client API should be simple and lean so bringing up new clients is low cost.

** Runtime

A typical lifecycle of the client and runtime may look like:

1. Clients opens a bidirectional channel to runtime.
2. Client and runtime trade message over bidirectional channel via client API.
3. When the client exists, it closes the channel, and runtime frees resources
   tied to connection.

The per-client state is maintained in the runtime, so client implemenation is
lean.

The client API will offer request-response style APIs on top of message passing
for convenience, but the channel is a bidirectional.

How the runtime is started may be platform dependent:

- On desktop, native service management may be used (`systemd`, `launchd`, etc).
- On web, runtime may be always running in the cloud.
- On mobile, a in-process runtime may be spun up before client initialization.

** Runtime - High Level Lifecycle

1. Runtime is initialized in host process
2. Host process begins listening on some transport for new connections
3. Host process hands-off accepted connections to runtime
4. Runtime spawns a dedicated client task per connection
5. Messages on client connection are forwarded to rest of runtime, such as
   the interpreter task
6. Responses are forwarded back on client connection
7. When client task ends or connection is disconnected, the task is terminated

** Client API

The client API should be lightweight.

It should support:

- Request / Response
- Pub / Sub - including pushes from runtime
- Hypermedia-Driven Interface

** Client Library

The client API is largely implemented by client library.

Like `libdbus`, the underlying transport should be opaque to client programs -
it may use lower-level IPC mechanisms like unix domain sockets, or TCP, without
affecting API surface between client and client library.

** Hypermedia Client

The client implementation over client API is hypermedia-driven:

TODO: Add notes on hypermedia client

** vrsctl - CLI client

The `vrsctl` CLI is lightweight client to runtime that offers 1-1 mapping to
client API.

Per invocation, it will:
1. Open connection with runtime
2. Send specified message(s)
3. Wait for response(s)
4. Close connection to runtime when stdin closes and all requests were processed.

CLI can be used to bootstrap new clients that is able to launch `vrsctl`
directly, or as a development tool.

NDJSON-based messages and syntactic sugar to it will be used to keep CLI
interaction close to client API as possible.

* Lemma Lang
** Why write your own Lisp?

Paul Graham put it best:

#+begin_quote
A language is by definition reusable. The more of your application you can push
down into a language for writing that type of application, the more of your
software will be reusable.
â€” Paul Graham
#+end_quote

When the language is tailored to the environment, software can be simple and
rich, similar to how shell languages are designed around IO redirection.

It is also my impression that a bulk of software written today fall into
standard, institutionalized patterns - with engineers acting as "human
compilers" to write this code out by hand. Why not let the computer write that
code via higher-level intermediate language?

See also - [Greeenspun's Tenth Rule](https://en.wikipedia.org/wiki/Greenspun's_tenth_rule)

** Lisp as the Uniform Interface

In vrs, it's Lisp all the way down:

- Scripting language is Lisp
- Modules extends runtime via bindings in Lisp
- User interfaces are s-expressions
- Hypermedia controls within interface are s-expressions
- Messages between client and runtime are s-expressions

Lisp is the substrate for code and data that ties the client, runtime, and
modules together.

Lisp is a practical choice for highly interactive, moldable,
application-specific progamming environments.

[Twitter rant](https://twitter.com/leoshimo/status/1694375158897574227)

*** Lisp as Hypermedia

v0.1 sketch of Lisp as Hypermedia

#+begin_src lisp
'((:text_field :id search
               :on_change on_search_text_change
               :value "query input")
  (:ul :id search_results
       (:li :content "Element 1"
            :on_click '(action_for_elem_1))
       (:li :content "Element 2"
            :on_click '(action_for_elem_2))
       (:li :content "Element 3"
            :on_click '(action_for_elem_3))))
#+end_src

** Quirk: Dynamic Scoping

Lemma uses dynamic scoping instead of lexical scoping today.

This is due to few reasons:
- Dynamic scoping is [very useful](https://www.gnu.org/software/emacs/emacs-paper.html#SEC17)
- It simplifies implementation of interpreter
- It simplifies implementation serialization of lemma expressions

It may be nice to default to lexical scoping and add closures if existing
utility of free variables can be provided by some other mechanism, e.g. a
stack-based parameter like Jai's context mechanism.

